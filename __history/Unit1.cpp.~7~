//---------------------------------------------------------------------------
#include <vcl.h>
#pragma hdrstop

#include "Unit1.h"
//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;
//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
	: TForm(Owner)
{
    String empty;
	Memo1->Text = empty;
	Memo2->Text = empty;
}
//---------------------------------------------------------------------------

vector<double> TForm1::split(const String& Str, const char& separator)
{
	double temp = NULL;
	string temp_str;
	vector<double> vec;

	for (int i = 1; i <= Str.Length(); i++) {
		temp_str += Str[i];
		if (Str[i] == separator || i == Str.Length()) {
			stringstream s(temp_str);
			s >> temp;
			if (temp != NULL)
				vec.push_back(temp);
			temp = NULL;
			temp_str.clear();
		}
	}
	return vec;
}


void __fastcall TForm1::Button1Click(TObject *Sender)
{
	int num_of_rows = Memo1->Lines->Count;
	vector<vector<double>> matrix;
	vector<int> num_of_values;

//    Text to matrix
	String Temp_str;
	vector<double> temp_vec;
	for (int i = 0; i < num_of_rows; i++) {
		Temp_str = Memo1->Lines->Strings[i];
		temp_vec = split(Temp_str, ' ');
		matrix.push_back(temp_vec);
		num_of_values.push_back(temp_vec.size());
//		ShowMessage(num_of_values[i]);
		temp_vec.clear();
	}

//    matrix to string
	vector<string> vec_str;
	for (int i = 0; i < num_of_rows; i++) {
		stringstream s;
		for (int j = 0; j < num_of_values[i]; j++) {
			s << setw(24) << matrix[i][j];
		}
		if (!s.str().empty())
			vec_str.push_back(s.str());
	}

//    string to String
//	Memo2->Text.~UnicodeString();
	String output;
//	Memo2->Text = output;
	for (int i = 0; i < num_of_rows; i++) {
		for (int j = 0; j < vec_str[i].length(); j++) {
			output += vec_str[i][j];
		}
		Memo2->Lines->Add(output);
		ShowMessage(output);
		output.~UnicodeString();
	}







/*
	for (auto &i: matrix) {
		if (i.size() != matrix[0].size()) {
			cout << "\n\nThe number of values is not same in each row."
				 << "\nRelaunch the MATRIX CALCULATOR and try to enter the matrix properly.\n\n";
			INPUT::show_original_matrix();
			cout << endl << endl;
			no_errors = false;
			break;
		}
	}
	if (no_errors) {
		cout << "\n\nThe entered matrix is with " << matrix.size() << " row(s) and "
			 << matrix[0].size() << " column(s):" << endl;
		INPUT::show_original_matrix();
		cout << endl << endl;
	}
*/





}
